-- hermes_schema_supabase.sql
set search_path = public;

-- ============================
-- TIPOS ENUM DE POSTGRES
-- ============================

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'budget_level_enum') THEN
    CREATE TYPE budget_level_enum AS ENUM ('low','medium','high');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'travel_style_enum') THEN
    CREATE TYPE travel_style_enum AS ENUM ('relaxed','adventure','cultural','mixed');
  END IF;
END$$;

-- ============================
-- 1. USUARIOS
-- ============================

CREATE TABLE IF NOT EXISTS users (
  user_id bigint GENERATED BY DEFAULT AS IDENTITY,
  full_name VARCHAR(100) NOT NULL,
  email VARCHAR(150) NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_active boolean NOT NULL DEFAULT true,
  CONSTRAINT users_pkey PRIMARY KEY (user_id),
  CONSTRAINT ux_users_email UNIQUE (email)
);

CREATE TABLE IF NOT EXISTS user_preferences (
  user_id bigint NOT NULL,
  preferred_language CHAR(5) DEFAULT NULL,
  preferred_currency CHAR(3) DEFAULT NULL,
  budget_level budget_level_enum DEFAULT NULL,
  travel_style travel_style_enum DEFAULT NULL,
  CONSTRAINT user_preferences_pkey PRIMARY KEY (user_id),
  CONSTRAINT fk_user_preferences_user
    FOREIGN KEY (user_id) REFERENCES users(user_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

-- Trigger para updated_at (opcional, pero útil)
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS set_users_updated_at ON users;
CREATE TRIGGER set_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- ============================
-- 2. GEOGRAFÍA
-- ============================

CREATE TABLE IF NOT EXISTS countries (
  country_id bigint GENERATED BY DEFAULT AS IDENTITY,
  name VARCHAR(100) NOT NULL,
  iso_code CHAR(2) NOT NULL,
  CONSTRAINT countries_pkey PRIMARY KEY (country_id),
  CONSTRAINT ux_countries_iso UNIQUE (iso_code),
  CONSTRAINT ux_countries_name UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS cities (
  city_id bigint GENERATED BY DEFAULT AS IDENTITY,
  country_id bigint NOT NULL,
  name VARCHAR(100) NOT NULL,
  region VARCHAR(100) DEFAULT NULL,
  latitude NUMERIC(9,6) DEFAULT NULL,
  longitude NUMERIC(9,6) DEFAULT NULL,
  CONSTRAINT cities_pkey PRIMARY KEY (city_id),
  CONSTRAINT fk_cities_country
    FOREIGN KEY (country_id) REFERENCES countries(country_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_cities_country ON cities(country_id);

-- ============================
-- 3. LUGARES Y CATEGORÍAS
-- ============================

CREATE TABLE IF NOT EXISTS place_categories (
  place_category_id bigint GENERATED BY DEFAULT AS IDENTITY,
  name VARCHAR(50) NOT NULL,
  description VARCHAR(255) DEFAULT NULL,
  CONSTRAINT place_categories_pkey PRIMARY KEY (place_category_id),
  CONSTRAINT ux_place_categories_name UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS places (
  place_id bigint GENERATED BY DEFAULT AS IDENTITY,
  city_id bigint NOT NULL,
  place_category_id bigint NOT NULL,
  name VARCHAR(150) NOT NULL,
  description TEXT DEFAULT NULL,
  address VARCHAR(255) DEFAULT NULL,
  latitude NUMERIC(9,6) DEFAULT NULL,
  longitude NUMERIC(9,6) DEFAULT NULL,
  average_rating NUMERIC(2,1) DEFAULT NULL,
  price_level SMALLINT DEFAULT NULL, -- 1 = barato, 5 = muy caro
  website VARCHAR(255) DEFAULT NULL,
  phone VARCHAR(50) DEFAULT NULL,
  is_recommended boolean NOT NULL DEFAULT false, -- 1 = recomendado
  CONSTRAINT places_pkey PRIMARY KEY (place_id),
  CONSTRAINT fk_places_city
    FOREIGN KEY (city_id) REFERENCES cities(city_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_places_category
    FOREIGN KEY (place_category_id) REFERENCES place_categories(place_category_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_places_city ON places(city_id);
CREATE INDEX IF NOT EXISTS idx_places_category ON places(place_category_id);

CREATE TABLE IF NOT EXISTS tags (
  tag_id bigint GENERATED BY DEFAULT AS IDENTITY,
  name VARCHAR(50) NOT NULL,
  CONSTRAINT tags_pkey PRIMARY KEY (tag_id),
  CONSTRAINT ux_tags_name UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS place_tags (
  place_id bigint NOT NULL,
  tag_id bigint NOT NULL,
  CONSTRAINT place_tags_pkey PRIMARY KEY (place_id, tag_id),
  CONSTRAINT fk_place_tags_place
    FOREIGN KEY (place_id) REFERENCES places(place_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_place_tags_tag
    FOREIGN KEY (tag_id) REFERENCES tags(tag_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_place_tags_tag ON place_tags(tag_id);

-- ============================
-- 4. TRANSPORTE
-- ============================

CREATE TABLE IF NOT EXISTS transport_modes (
  mode_id bigint GENERATED BY DEFAULT AS IDENTITY,
  name VARCHAR(50) NOT NULL,
  CONSTRAINT transport_modes_pkey PRIMARY KEY (mode_id),
  CONSTRAINT ux_transport_modes_name UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS routes (
  route_id bigint GENERATED BY DEFAULT AS IDENTITY,
  origin_city_id bigint NOT NULL,
  destination_city_id bigint NOT NULL,
  mode_id bigint NOT NULL,
  name VARCHAR(150) DEFAULT NULL,
  distance_km NUMERIC(7,2) DEFAULT NULL,
  average_duration_min INT DEFAULT NULL,
  average_price NUMERIC(10,2) DEFAULT NULL,
  CONSTRAINT routes_pkey PRIMARY KEY (route_id),
  CONSTRAINT fk_routes_origin_city
    FOREIGN KEY (origin_city_id) REFERENCES cities(city_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_routes_destination_city
    FOREIGN KEY (destination_city_id) REFERENCES cities(city_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_routes_mode
    FOREIGN KEY (mode_id) REFERENCES transport_modes(mode_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_routes_origin ON routes(origin_city_id);
CREATE INDEX IF NOT EXISTS idx_routes_destination ON routes(destination_city_id);
CREATE INDEX IF NOT EXISTS idx_routes_mode ON routes(mode_id);

-- ============================
-- 5. VIAJES (PLANES / ITINERARIOS)
-- ============================

CREATE TABLE IF NOT EXISTS trips (
  trip_id bigint GENERATED BY DEFAULT AS IDENTITY,
  user_id bigint NOT NULL,
  title VARCHAR(150) NOT NULL,
  description TEXT DEFAULT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  total_budget NUMERIC(10,2) DEFAULT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT trips_pkey PRIMARY KEY (trip_id),
  CONSTRAINT fk_trips_user
    FOREIGN KEY (user_id) REFERENCES users(user_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_trips_user ON trips(user_id);

DROP TRIGGER IF EXISTS set_trips_updated_at ON trips;
CREATE TRIGGER set_trips_updated_at
BEFORE UPDATE ON trips
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TABLE IF NOT EXISTS trip_days (
  trip_day_id bigint GENERATED BY DEFAULT AS IDENTITY,
  trip_id bigint NOT NULL,
  date DATE NOT NULL,
  day_index INT NOT NULL,
  CONSTRAINT trip_days_pkey PRIMARY KEY (trip_day_id),
  CONSTRAINT ux_trip_days_trip_date UNIQUE (trip_id, date),
  CONSTRAINT ux_trip_days_trip_day_index UNIQUE (trip_id, day_index),
  CONSTRAINT fk_trip_days_trip
    FOREIGN KEY (trip_id) REFERENCES trips(trip_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_trip_days_trip ON trip_days(trip_id);

CREATE TABLE IF NOT EXISTS trip_activities (
  activity_id bigint GENERATED BY DEFAULT AS IDENTITY,
  trip_day_id bigint NOT NULL,
  place_id bigint DEFAULT NULL,
  route_id bigint DEFAULT NULL,
  start_time TIME DEFAULT NULL,
  end_time TIME DEFAULT NULL,
  notes TEXT DEFAULT NULL,
  estimated_cost NUMERIC(10,2) DEFAULT NULL,
  CONSTRAINT trip_activities_pkey PRIMARY KEY (activity_id),
  CONSTRAINT fk_trip_activities_trip_day
    FOREIGN KEY (trip_day_id) REFERENCES trip_days(trip_day_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_trip_activities_place
    FOREIGN KEY (place_id) REFERENCES places(place_id)
    ON DELETE SET NULL
    ON UPDATE CASCADE,
  CONSTRAINT fk_trip_activities_route
    FOREIGN KEY (route_id) REFERENCES routes(route_id)
    ON DELETE SET NULL
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_trip_activities_day ON trip_activities(trip_day_id);
CREATE INDEX IF NOT EXISTS idx_trip_activities_place ON trip_activities(place_id);
CREATE INDEX IF NOT EXISTS idx_trip_activities_route ON trip_activities(route_id);

-- ============================
-- 6. VISTAS DE RECOMENDADOS
-- ============================

CREATE OR REPLACE VIEW view_recommended_restaurants AS
SELECT
  p.*,
  c.name AS city_name,
  co.name AS country_name
FROM places p
JOIN cities c ON p.city_id = c.city_id
JOIN countries co ON c.country_id = co.country_id
JOIN place_categories pc ON p.place_category_id = pc.place_category_id
WHERE pc.name = 'Restaurant'
  AND p.is_recommended = TRUE;

CREATE OR REPLACE VIEW view_recommended_lodgings AS
SELECT
  p.*,
  c.name AS city_name,
  co.name AS country_name
FROM places p
JOIN cities c ON p.city_id = c.city_id
JOIN countries co ON c.country_id = co.country_id
JOIN place_categories pc ON p.place_category_id = pc.place_category_id
WHERE pc.name IN ('Hotel','Hostel','Apartment')
  AND p.is_recommended = TRUE;

-- ============================
-- 7. TABLA UNIFICADA DE ACTIVIDADES POR DÍA (trip_events)
-- ============================

-- Unifica "trip_days" y "trip_activities" para simplificar el flujo de registro y consulta.
-- Esta sección puede ejecutarse como migración adicional en la base de datos.

CREATE TABLE IF NOT EXISTS trip_events (
  event_id bigint GENERATED BY DEFAULT AS IDENTITY,
  trip_id bigint NOT NULL,
  date DATE NOT NULL,
  start_time TIME NOT NULL,
  end_time TIME DEFAULT NULL,
  notes TEXT DEFAULT NULL,
  place_name TEXT DEFAULT NULL,
  estimated_cost NUMERIC(10,2) DEFAULT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT trip_events_pkey PRIMARY KEY (event_id),
  CONSTRAINT fk_trip_events_trip
    FOREIGN KEY (trip_id) REFERENCES trips(trip_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_trip_events_trip ON trip_events(trip_id);
CREATE INDEX IF NOT EXISTS idx_trip_events_trip_date ON trip_events(trip_id, date);

DROP TRIGGER IF EXISTS set_trip_events_updated_at ON trip_events;
CREATE TRIGGER set_trip_events_updated_at
BEFORE UPDATE ON trip_events
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- (Opcional) Migración básica de datos desde trip_days + trip_activities
-- Ejecutar estas sentencias manualmente en tu base si ya tienes datos.
 -- INSERT INTO trip_events (trip_id, date, start_time, end_time, notes, estimated_cost)
 -- SELECT td.trip_id, td.date, ta.start_time, ta.end_time, ta.notes, ta.estimated_cost
-- FROM trip_days td
-- JOIN trip_activities ta ON ta.trip_day_id = td.trip_day_id;

-- ============================
-- 8. MIGRACIÓN: ELIMINAR activity_type
-- ============================
-- Para bases ya existentes, elimina la columna y el tipo ENUM.
-- Ejecutar estas sentencias en la base (idempotentes):
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'trip_events' AND column_name = 'activity_type'
  ) THEN
    EXECUTE 'ALTER TABLE public.trip_events DROP COLUMN IF EXISTS activity_type';
  END IF;
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'trip_activities' AND column_name = 'activity_type'
  ) THEN
    EXECUTE 'ALTER TABLE public.trip_activities DROP COLUMN IF EXISTS activity_type';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_type WHERE typname = 'activity_type_enum') THEN
    EXECUTE 'DROP TYPE IF EXISTS activity_type_enum';
  END IF;
END$$;
-- Chat sessions and messages for persistent chatbot history
CREATE TABLE IF NOT EXISTS public.chat_sessions (
  chat_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES public.users(user_id) ON DELETE CASCADE,
  title TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.chat_messages (
  message_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chat_id BIGINT NOT NULL REFERENCES public.chat_sessions(chat_id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES public.users(user_id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user','assistant','system')),
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.chat_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;

-- Policies: users can manage only their own sessions and messages
CREATE POLICY chat_sessions_select ON public.chat_sessions
  FOR SELECT USING (auth.uid() IS NOT NULL AND EXISTS (
    SELECT 1 FROM public.users u WHERE u.user_id = chat_sessions.user_id AND u.email = auth.email()
  ));
CREATE POLICY chat_sessions_insert ON public.chat_sessions
  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL AND EXISTS (
    SELECT 1 FROM public.users u WHERE u.user_id = chat_sessions.user_id AND u.email = auth.email()
  ));
CREATE POLICY chat_sessions_delete ON public.chat_sessions
  FOR DELETE USING (auth.uid() IS NOT NULL AND EXISTS (
    SELECT 1 FROM public.users u WHERE u.user_id = chat_sessions.user_id AND u.email = auth.email()
  ));

CREATE POLICY chat_messages_select ON public.chat_messages
  FOR SELECT USING (auth.uid() IS NOT NULL AND EXISTS (
    SELECT 1 FROM public.users u WHERE u.user_id = chat_messages.user_id AND u.email = auth.email()
  ));
CREATE POLICY chat_messages_insert ON public.chat_messages
  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL AND EXISTS (
    SELECT 1 FROM public.users u WHERE u.user_id = chat_messages.user_id AND u.email = auth.email()
  ));
CREATE POLICY chat_messages_delete ON public.chat_messages
  FOR DELETE USING (auth.uid() IS NOT NULL AND EXISTS (
    SELECT 1 FROM public.users u WHERE u.user_id = chat_messages.user_id AND u.email = auth.email()
  ));
